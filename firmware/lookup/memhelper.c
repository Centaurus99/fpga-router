#include "memhelper.h"
#include <assert.h>
#include <stdio.h>

#ifdef TRIVIAL_MALLOC
int node_tops[STAGE_COUNT] = {1, 1, 1, 1, 1, 1, 1, 1};
bool node_used[STAGE_COUNT][NODE_COUNT_PER_STAGE] = {{1}};
int leaf_top = 1;
bool leaf_used[LEAF_NODE_COUNT];


int node_malloc(int stage, int len) {
    node_tops[stage] += len;
    assert(node_tops[stage] <= NODE_COUNT_PER_STAGE);
    for (int i=node_tops[stage]-len; i<node_tops[stage]; ++i) {
        node_used[stage][i] = true;
    }
#ifdef TRACE
    printf("N %d %d +\n", stage, len);
#endif

    return node_tops[stage] - len;
}

void node_free(int stage, int begin, int len) {
    for (int i=begin; i<begin+len; ++i) {
        node_used[stage][i] = false;
    }
#ifdef TRACE
    printf("N %d %d -\n", stage, len);
#endif
}

bool is_node_used(int stage, int id) {
    return node_used[stage][id];
}

int leaf_malloc(int len) {
    leaf_top += len;
    assert(leaf_top <= LEAF_NODE_COUNT);
    for (int i=leaf_top-len; i<leaf_top; ++i) {
        leaf_used[i] = true;
    }
#ifdef TRACE
    printf("L %d +\n", len);
#endif
    return leaf_top - len;
}

void leaf_free(int begin, int len) {
    for (int i=begin; i<begin+len; ++i) {
        leaf_used[i] = false;
    }
#ifdef TRACE
    printf("L %d -\n", len);
#endif
}

bool is_leaf_used(int id) {
    return leaf_used[id];
}

void memhelper_init() {

}

#else
// 164419 insertions, run 1 times, +5, 1.0x size
int node_blk_cnt[8][17] = {
	{1013  ,11    ,8     ,6     ,6     ,6     ,6     ,6     ,6     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,23    },  // 2 BRAMS
	{33787 ,3188  ,2332  ,1271  ,440   ,146   ,133   ,114   ,118   ,121   ,132   ,121   ,120   ,124   ,135   ,182   ,355   },  // 66 BRAMS
	{81909 ,28649 ,4887  ,2448  ,1652  ,693   ,570   ,425   ,409   ,223   ,171   ,143   ,138   ,117   ,99    ,123   ,294   },  // 160 BRAMS
	{1016  ,14    ,6     ,6     ,7     ,6     ,6     ,6     ,6     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,23    },  // 2 BRAMS
	{1016  ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,26    },  // 2 BRAMS
	{1016  ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,26    },  // 2 BRAMS
	{1016  ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,26    },  // 2 BRAMS
	{1016  ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,5     ,26    }}; // 2 BRAMS
int leaf_blk_cnt[17] = 
	{193526,41852 ,8323  ,4214  ,3147  ,1275  ,1065  ,887   ,931   ,652   ,653   ,635   ,612   ,628   ,675   ,789   ,1700  };
#ifndef ON_BOARD
TrieNode node_pool[121789]; // 238 BRAMS
extern TrieNode *_nodes[8];
#endif
int blk_pool[118743];
// ---generated by trace.py END---

int *free_blk[9][17];
int free_blk_top[9][17], blk_begin[9][17];

void _blk_push(int stage, int len, int id) {
    // printf("PUSH %d %d %d\n", stage, len, id);
    assert_id(free_blk_top[stage][len] < (stage < 8 ? node_blk_cnt[stage][len]: leaf_blk_cnt[len]), 4);
    free_blk[stage][len][free_blk_top[stage][len]++] = id;
}
int _blk_pop(int stage, int len) {
    if (free_blk_top[stage][len] <= 0)
        return -1;
    // printf("POP %d %d\n", stage, len);
    return free_blk[stage][len][--free_blk_top[stage][len]];
}

void memhelper_init() {
    assert_id(sizeof(LeafNode) * leaf_blk_cnt[0] < (LEAF_INFO_ADDRESS - LEAF_ADDRESS), 0xfd);
    assert_id(sizeof(LeafInfo) * LEAF_INFO_COUNT < (EXT_RAM_END - LEAF_INFO_ADDRESS), 0xfd);
    int cnt = 0;
    int begin = 0;
#ifndef ON_BOARD
    int nodes_begin = 0;
#endif
    for (int i = 0; i < 8; ++i) {
#ifndef ON_BOARD
        _nodes[i] = &node_pool[nodes_begin];
        nodes_begin += node_blk_cnt[i][0];
#endif
        begin = 0;
        for (int j = 1; j < 17; ++j) {
            free_blk[i][j] = &blk_pool[cnt];
            for (int k = 0; k < node_blk_cnt[i][j]; ++k) {
                _blk_push(i, j, k);
            }
            cnt += node_blk_cnt[i][j];

            blk_begin[i][j] = begin;
            begin += node_blk_cnt[i][j] * j;
        }
    }
    begin = 0;
    for (int j = 1; j < 17; ++j) {
        free_blk[8][j] = &blk_pool[cnt];
        cnt += leaf_blk_cnt[j];
        for (int k = 0; k < leaf_blk_cnt[j]; ++k) {
            _blk_push(8, j, k);
        }

        blk_begin[8][j] = begin;
        begin += leaf_blk_cnt[j] * j;
    }
}

int node_malloc(int stage, int len) {
    int id = _blk_pop(stage, len);
    while (id == -1) { // 挤到更大的块里
        assert_id(len < 16, 0x13);
        id = _blk_pop(stage, ++len); // TODO: 记录一下，如果这种小占大的把大的给占满了 应该把小的再挪回去
    }
    assert_id(blk_begin[stage][len] + id*len + len <= node_blk_cnt[stage][0], 0x23);
#ifdef TRACE
    printf("N %d %d +\n", stage, len);
#endif
    return blk_begin[stage][len] + id*len;
}

void node_free(int stage, int begin, int len) {
    // printf("NF %d %d %d %d\n",stage,begin,len);
    while (len < 16 && begin >= blk_begin[stage][len+1]) ++len; // 找到真正的块大小
    int id = (begin - blk_begin[stage][len]) / len;
    assert_id(id < node_blk_cnt[stage][len], 0x33);
#ifdef TRACE
    printf("N %d %d -\n", stage, len);
#endif
    _blk_push(stage, len, id);
}

// bool is_node_used(int stage, int id) {return 0;} // HACK: 应该是不需要实现了

int leaf_malloc(int len) {
    int id = _blk_pop(8, len);
    while (id == -1) { // 挤到更大的块里
        assert_id(len < 16, 0x43);
        id = _blk_pop(8, ++len); // TODO: 记录一下，如果这种小占大的把大的给占满了 应该把小的再挪回去
    }
    assert_id(blk_begin[8][len] + id*len + len < LEAF_NODE_COUNT, 4);
#ifdef TRACE
    printf("L %d +\n", len);
#endif
    return blk_begin[8][len] + id*len;
}

void leaf_free(int begin, int len) {
    while (len < 16 && begin >= blk_begin[8][len+1]) ++len;
    // printf("%d %d\n",begin ,len);
    int id = (begin - blk_begin[8][len]) / len;
    assert_id(id < leaf_blk_cnt[len], 4);
#ifdef TRACE
    printf("L %d -\n", len);
#endif
    _blk_push(8, len, id);
}

// bool is_leaf_used(int id) {return 0;} // HACK: 应该是不需要实现了

#endif